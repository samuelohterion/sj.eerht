<!DOCTYPE html>
<html>

	<head>

		<meta charset="utf-8" />

		<title>Dynamic Checkerboard</title>

		<style type="text/css">

		</style>
<!--
		<script src="../../three.js/build/three.js" type="text/javascript"></script>

		<script src="../../three.js/examples/js/controls/OrbitControls.js" type="text/javascript"></script>
-->
		<script src="https://threejs.org/build/three.js" type="text/javascript"></script>

		<script src="https://threejs.org/examples/js/controls/OrbitControls.js" type="text/javascript"></script>

		<script src="mesh.js" type="text/javascript"></script>

	</head>

	<body>

		<button id="startStop" onclick="startStop( );">start simulaion</button>

		<button id="reset" onclick="reset( );">reset</button>

		<script type="text/javascript">

			var
			btnStartStop = document.getElementById( "startStop" );

			var
			run  = false,
			tm   = ( new Date ( ) ).getTime ( ),
			then = ( new Date ( ) ).getTime ( ) - tm,
			now  = ( new Date ( ) ).getTime ( ) - tm;

			var
			cmr  = new THREE.PerspectiveCamera ( 60, window.innerWidth / window.innerHeight, .1, 10000 );
			cmr.position.set ( 0., 50., 100. );
			cmr.up.set( 0, 1, 0 );
			cmr.lookAt( new THREE.Vector3 ( 0, 0, 0 ) );

			var
			rndr = new THREE.WebGLRenderer ( );
			rndr.setSize ( window.innerWidth, window.innerHeight );
			rndr.shadowMap.enabled = true;
			rndr.shadowMapType = THREE.PCFSoftShadowMap;
			document.body.appendChild ( rndr.domElement );

			var
			oCtl = new THREE.OrbitControls( cmr );
			oCtl.addEventListener( 'change', render );

			var
			scn = new THREE.Scene( );

			var
			lta = new THREE.AmbientLight( 0x404040, 2 ),
			lgt = new THREE.PointLight( 0xa0c0ff, 10, 500. ),
			lth = new THREE.PointLightHelper( lgt, 10 );
			lgt.position.set( 0, 300, 0 );
			lgt.castShadow = true;

			//lgt.shadowDarkness = .5;
			scn.add( lta );
			scn.add( lgt );
			scn.add( lth );

			var
			objGm = new THREE.Geometry ( ),
			myGmtr = new My.Gmtr ( 1000 );

			objGm.faces    = myGmtr.f;
			objGm.vertices = myGmtr.v;

			objGm.computeFaceNormals ( );
			objGm.computeVertexNormals ( );

			var
			objMt = new THREE.MeshPhongMaterial ( { vertexColors: THREE.FaceColors, side: THREE.DoubleSide } ),
			obj   = new THREE.Mesh ( objGm, objMt );

			scn.add ( obj );


			myGmtr.move( 0, 0, 0 );

			reset( );

			function animate ( ) {

				if ( !run )

					return;

				requestAnimationFrame ( animate );

				now  = ( new Date ( ) ).getTime ( ) - tm;

				var
				dt = 1e-3 * ( now - then );

				then = now;

				if( 1. < dt || dt < 1. / 120. )

					return;

				var
				id = 0,
				vs = myGmtr.v,
				fc = myGmtr.f;

				objGm.verticesNeedUpdate = true;
				objGm.normalsNeedUpdate = true;
				objGm.colorsNeedUpdate = true;
//				objGm.dynamic = true;
/*
				var
				cx = 0,
				cz = 0,
				fx = 0,
				fz = 0;

				for ( var i = 0; i < wt; ++i ) {

					cx = i - wh;

					for ( var j = 0; j < wt; ++j ) {

						cz = j - wh;

						for ( var x = 0; x < 2; ++x ) {

							fx = ( cx + x );
							fx *= fx;

							for ( var z = 0; z < 2; ++z ) {

								fz = ( cz + z );
								fz *= fz;

//								if ( id & 4  ) {
								if ( objGm.faces[ id >> 1 ].color.r < .5 ) {

									vs[ id ].y = 1e-1 * Math.sin( .00023 * now ) * ( wh * wh - fx + fz ) * Math.sin ( .0032 * now + .0042 * ( Math.sin( .000123 * now ) * fx + Math.cos( .000153 * now ) * fz ) );
								}
								else {

									vs[ id ].y = 1e-1 * Math.cos( .00013 * now ) * ( wh * wh - fx + fz ) * Math.sin ( .002 * now + .0027* ( Math.sin( .000153 * now ) * fx + Math.cos( .000159 * now ) * fz ) );
								}
								++id;
							}
						}
					}
				}

//				eightQueensPuzzle.work ( );
*/
				var
				i = parseInt ( .05 * now ),
				j = i % myGmtr.f.length;

				paintTrngl ( j, .5 * ( 1. + Math.sin ( .001 * i ) ), .5 * ( 1. + Math.sin ( .01 * i ) ), .5 * ( 1. + Math.sin ( .00001 * i * i ) ) );

				render ( );
			}

			function render ( ) {

				rndr.render ( scn, cmr );
			}

			function reset( ) {

				tm   = ( new Date ( ) ).getTime ( );
				then = ( new Date ( ) ).getTime ( ) - tm;
				now  = ( new Date ( ) ).getTime ( ) - tm;

				objGm.computeFaceNormals ( );
				objGm.computeVertexNormals ( );

				requestAnimationFrame ( render );
			}

			function startStop ( ) {

				if( run ) {

					run = false;

					btnStartStop.innerHTML = "start simulation";

					return;
				}

				tm = ( new Date ( ) ).getTime ( );

				run = true;

				btnStartStop.innerHTML = "stop simulation";

				animate ( );
			}

			function paintTrngl ( idx, pR, pG, pB ) {

				myGmtr.f[ idx ].color.r = pR;
				myGmtr.f[ idx ].color.g = pG;
				myGmtr.f[ idx ].color.b = pB;

				var
				v1 = new THREE.Vector3 ( 20. * Math.cos ( 1e-3 * now ), 20. * Math.sin ( 1e-3 * now ), 100. * Math.sin ( 1.2345678e-3 * now ) ),
				v2 = v1.clone ( ).add ( new THREE.Vector3 ( +4 + 2. * Math.sin ( 1e-2 * now ), 0,  4 + 2 * Math.cos ( 1e-2 * now ) ) );
				v3 = v1.clone ( ).add ( new THREE.Vector3 ( +4 + 1. * Math.sin ( 1e-2 * now ), 5,  4 + 1 * Math.cos ( 1e-2 * now ) ) );

				myGmtr.v[ myGmtr.f[ idx ].a ].copy ( v1 );
				myGmtr.v[ myGmtr.f[ idx ].b ].copy ( v2 );
				myGmtr.v[ myGmtr.f[ idx ].c ].copy ( v3 );
			}


			animate ( );
		</script>

	</body>

</html>
